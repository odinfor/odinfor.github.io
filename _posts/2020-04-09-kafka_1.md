---
layout: post
title: "「中间件」kafka学习笔记(一)"
subtitle: 'kafka概述以及kafka架构解析'
author: "odin"
header-style: text
tags:
  - 中间件
---

#### 什么是kafka
kafka是一种分布式的基于发布/订阅模式的消息中间件，主要应用于大数据实时分析领域。Kafka是最初由Linkedin公司开发，由scala和java编写，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做MQ系统），常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。
主要应用场景：日志收集系统和消息系统。

#### kafka主要设计特性
1. 高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输。
2. "零"复制机制。减少用户太的数据复制，只保留内核态的数据复制，从而达到快速IO。
3. topic分区
4. 以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能。
5. 同时支持离线数据处理和实时数据处理。
6. 支持分区扩展。topic分区(partition)可以增加，但是不能减少。
7. 局部有序性。在一个分区内是有序的。

#### kafka总体架构
![]({{site.baseurl}}/img/in-post/post-middleware/kafka_总体架构.jpg)
<center>网络图片</center>

从总体架构上也能看出，kafka是基于zookeeper的，依赖zookeeper存储offset(偏移量，在kafka 0.9版本以前，0.9版本之后offset存储在kafka自身默认的consemuer topic中)，以及依赖zookeeper进行controller抢占注册。
> kafka controller，作为kafka的控制器作用后续会讲，先提一下就是全局唯一，负责管理整个集群中所有分区和副本的状态，例如为分区xuanquu新的leader。抢占注册机制可以理解成抢锁机制，先到先得。

kafka总体架构分为：
* produce：生产者。
* broker：kafka集群中的服务节点。
* consumer：消费者/订阅者，consumer有组的概念，consumergroup。一个consumergroup组内多个consumer，kafka通过这种方式提高吞吐量。
* topic：消息主题。每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）。
* partition：topic分区，是物理上的概念，每个topic包含一个或者多个partition。**一个partition只能被一个consumer消费，若是对应consumergroup，那么也是只能对应xonsumergroup中的一个consumer，同一个partition不能被多个consumer消费。**kafka通过在每个broker上分配多个partition实现高可用和可扩展性。
    > 为什么不能减少分区？  
    > kafka的分区减少会面临partition和consumer的重新划分，又要保证partition中保留的数据不丢失和重复，实现过程很复杂，所以官方没有实现这个规则策略，规定只能增加不能减少。
* replica：副本，保证kafka集群中某个节点发生故障，该节点上的数据不丢失，kafka提供副本机制。topic的每个分区都有一个leader, 若干个follower,和replica。

> 基于partition只能对应一个consumer的特性，在kafka集群架构设计上我们需要注意的是，consumer的节点不要多于partition，否则多出来的consumer不会进行消费。若partiton多于consumer，kafka会通过分区策略(roundrobin和xrange)进行规划，后续详细讲解。

#### kafka创建tpoic流程
没有深入了解，这里简单概述一下kafka创建topic流程，详细过程建议阅读kafka源码或者google。

![]({{site.baseurl}}/img/in-post/post-middleware/kafka_create_topic_process.jpg)

kafka 0.9之前的版本和0.9之后的版本有区别，这里以0.9之后的版本为例说明
kafka创建topic流程：
1. 首先在zookeeper上创建相应topic名称的节点。
2. kafka组件controller监控到zookeeper上节点变化，并创建topic缓存在kafka中。

#### kafka集群节点分布
kafka集群中维护着相关的状态信息，不同的状态信息具有不同的作用。包含同步选举使用的节点信息和副本所在节点信息。可以通过客户端`--describe --topic name`命令指定topic查看该topic的集群节点信息查看。
![]({{site.baseurl}}/img/in-post/post-middleware/kafka_describe.jpg)
查看结果看出，名为first的topic有3个partition，以partition：0来说，
replicas：1,2，代表一个副本在节点1上另外一个副本在节点2上，那么必然其中一个是leader，另外一个是follower。
leader：1说明leader是broker=1。
最后有一个描述Isr，这个是一个重要的内容。记录的是与leader保持同步的follower的集合。**作为kafka重新选举的候选节点池，当leader挂掉后kafka会从Isr集合中的节点选举新的leader。**
> 当follower节点与leader节点断开连接超时，follower节点会从Isr列表中移除，follower节点恢复并从leader节点同步完数据后重新加入Isr集合列表中。











##### 参考文章

https://kfly.top/2020/01/07/it/kafka%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/